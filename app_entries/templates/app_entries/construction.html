{% extends "base.html" %}

{% block title %}Construction Details - {{ title }}{% endblock %}

{% block content %}

    <h1>{{ title }}</h1>
    <table border="1">
        {% for triple in triples %}
            <tr>
                <th>{{ triple.property }}</th>
                <td>{% if triple.property == 'Meaning of the construction' %}{{ triple.object|safe }}{% else %}{{ triple.object }}{% endif %}</td>
            </tr>
        {% endfor %}
    </table>

    {% if elements %}
    <h2>Construction elements</h2>
    <div id="table-container"></div>

<script>
// Accessing elements sent by Flask
const rawElements = {{ elements | tojson }};

//---------------------------------------------
// 0. Helper: extract numeric index from label "Element N"
// returns integer N or null if not found
//---------------------------------------------
function extractElementNumber(label) {
    if (!label || typeof label !== 'string') return null;
    const m = label.match(/\d+/);
    return m ? parseInt(m[0], 10) : null;
}

//---------------------------------------------
// 1. Build map: subject → children[]
//---------------------------------------------
function buildChildrenMap(data) {
    const map = {};
    data.forEach(item => {
        if (item.subject && item.children) {
            map[item.subject] = item.children;
        }
    });
    return map;
}
const childrenMap = buildChildrenMap(rawElements);

//---------------------------------------------
// 2. Extract only top-level property entries
//    (we keep children in childrenMap; do not flatten)
//---------------------------------------------
function extractTopLevel(entries) {
    const result = [];
    entries.forEach(item => {
        if (item.subject && item.property) {
            result.push(item);
        }
        // children left intact in childrenMap
    });
    return result;
}
const elements = extractTopLevel(rawElements);

//---------------------------------------------
// 3. Build main table data mapping
//---------------------------------------------
function createCrossTable(data) {

    const subjects = [...new Set(data.map(item => item.subject))];
    const properties = [...new Set(data.map(item => item.property))];

    // 2D map to store arrays of {object, href}
    const tableData = {};
    properties.forEach(property => {
        tableData[property] = {};
        subjects.forEach(subject => {
            tableData[property][subject] = [];
        });
    });

    // Populate with object + href
    data.forEach(({ subject, property, object, href }) => {
        tableData[property][subject].push({ object, href });
    });

    const desiredOrder = [
        'Phonology', 'Surface form', 'Root', 'Stem / Lemma', 'hasTransliteration',
        'hasTranslation', 'Syntactic form', 'Optionality', 'WordOrder',
        'Syntactic function', 'Semantic role', 'Semantic contribution',
        'Semantic property', 'has animacy', 'hasGender', 'has number',
        'hasPerson', 'hasCaseFeature', 'has tense', 'hasMode',
        'has voice', 'Information Structure' , 'type', 'comment', 'Colloprofile'
    ];

    // Define colors (palette)
    const colors = [
        '#F94144','#F8961E','#F9C74F','#90BE6D','#43AA8B','#577590',
        '#FFD1DC','#E6E6FA','#98FB98','#F0E68C','#FFB6C1','#FFA07A',
        '#DDA0DD','#90EE90'
    ];

    //---------------------------------------------
    // Helper: get color for a subject label using its element number
    // If no number found, fallback to using the column index (fallbackIndex)
    //---------------------------------------------
    function colorForLabel(label, fallbackIndex = 0) {
        const num = extractElementNumber(label);
        if (Number.isInteger(num) && num > 0) {
            return colors[(num - 1) % colors.length];
        }
        // fallback: use given index
        return colors[fallbackIndex % colors.length];
    }

    //---------------------------------------------
    // Helper: render only top-level values for a cell
    //---------------------------------------------
    function renderTopLevelValues(values) {
        return values.map(v =>
            v.href ? `<a href="${v.href}" target="_blank">${v.object}</a>` : v.object
        ).join('<br>');
    }

    //---------------------------------------------
    // Helper: build nested table HTML for a subject (once)
    //---------------------------------------------
    function buildNestedTableFor(subject) {
        const children = childrenMap[subject];
        if (!children || children.length === 0) return ''; // no children

        // child subject names (Element 3, Element 4, ...)
        const childSubjects = [...new Set(children.map(ch => ch.subject))];

        // all properties present in children, sorted by desiredOrder
        let childProperties = [...new Set(children.map(ch => ch.property))];

        // sort using desiredOrder; unknown properties go at the end
        childProperties.sort((a, b) => {
            const ia = desiredOrder.indexOf(a);
            const ib = desiredOrder.indexOf(b);

            if (ia === -1 && ib === -1) return a.localeCompare(b);     // both not in desiredOrder → alphabetical
            if (ia === -1) return 1;                                   // a after b
            if (ib === -1) return -1;                                  // b after a
            return ia - ib;                                            // both inside desiredOrder → compare index
        });


        // group child data by property and subject
        const nestedTableData = {};
        childProperties.forEach(p => nestedTableData[p] = {});
        children.forEach(({ subject: chSubj, property, object, href }) => {
            if (!nestedTableData[property][chSubj]) nestedTableData[property][chSubj] = [];
            nestedTableData[property][chSubj].push({ object, href });
        });

        // Build nested table HTML (single nested table returned)
        let nested = `<table class="nested-table" style="border-collapse:collapse; margin-top:6px; width:100%;">`;

        // Header row: blank corner + child subjects — use color based on element number
        nested += `<tr><td style="padding:4px 6px;"></td>${childSubjects.map((s, i) => {
            const bg = colorForLabel(s, i);
            return `<td style="padding:4px 6px; font-weight:bold; text-align:center; background-color:${bg};">${s}</td>`;
        }).join('')}</tr>`;

        // Rows: one per child property
        childProperties.forEach(prop => {
            nested += `<tr>`;
            nested += `<td style="padding:4px 6px; font-weight:bold;">${prop}</td>`;
            nested += childSubjects.map(s => {
                const vals = nestedTableData[prop][s] || [];
                return `<td style="padding:4px 6px;">${vals.map(v =>
                    v.href ? `<a href="${v.href}" target="_blank">${v.object}</a>` : v.object
                ).join('<br>')}</td>`;
            }).join('');
            nested += `</tr>`;
        });

        nested += `</table>`;
        return nested;
    }

    //---------------------------------------------
    // Build main table DOM
    //---------------------------------------------
    const table = document.createElement('table');
    const tbody = document.createElement('tbody');

    // Header row: empty corner + top-level subjects with color (use element number if present)
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `<td></td>` +
        subjects.map((subject, index) => {
            const bg = colorForLabel(subject, index);
            return `<td style="color:#3d3d3d; font-weight:bold; text-align:center; background-color:${bg};">${subject}</td>`;
        }).join('');
    tbody.appendChild(headerRow);

    // Main property rows: only top-level values (no nested table repeated here)
    desiredOrder.forEach(property => {
        if (tableData[property]) {
            const row = document.createElement('tr');

            const cells = [
                `<td style="font-weight:bold; vertical-align:top; padding:6px 8px;">${property}</td>`,
                ...subjects.map(subject =>
                    `<td style="vertical-align:top; padding:6px 8px;">${renderTopLevelValues(tableData[property][subject])}</td>`
                )
            ];

            row.innerHTML = cells.join('');
            tbody.appendChild(row);
        }
    });

    //---------------------------------------------
    // Now append ONE extra row that holds nested subtables,
    // placed under each subject column (subject without children -> empty cell)
    //---------------------------------------------
    const nestedRow = document.createElement('tr');

    // first cell can be left blank or show a label
    nestedRow.innerHTML = `<td style="font-weight:bold; vertical-align:top; padding:6px 8px;"></td>` +
        subjects.map(subject => {
            const nestedHTML = buildNestedTableFor(subject);
            return nestedHTML
                ? `<td style="vertical-align:top; padding:6px 8px;">${nestedHTML}</td>`
                : `<td style="vertical-align:top; padding:6px 8px;"></td>`;
        }).join('');

    tbody.appendChild(nestedRow);

    table.appendChild(tbody);
    return table;
}

// Render the table
const container = document.getElementById('table-container');
container.appendChild(createCrossTable(elements));
</script>


{% endif %}

{% if colloprofiles %}
 {% for profile in colloprofiles %}
    <div class="chart-container">
      <div class="chart-title">Colloprofile for {{ profile.subject_name }}</div>
      <canvas id="chart-{{ loop.index }}"></canvas>
    </div>
  {% endfor %}

  <script>
    {% for profile in colloprofiles %}
      const ctx{{ loop.index }} = document.getElementById('chart-{{ loop.index }}').getContext('2d');
      new Chart(ctx{{ loop.index }}, {
        type: 'bar',
        data: {
          labels: {{ profile.collocations|map(attribute='word')|list|tojson|safe }},
          datasets: [{
            label: 'Frequency',
            data: {{ profile.collocations|map(attribute='frequency')|list|tojson|safe }},
            backgroundColor: '#b3c5ff',
            borderColor: '#0056b3',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: false,  // Title is already rendered in HTML
            },
            legend: {
              display: true,
              position: 'top'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Frequency'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Collocations'
              }
            }
          }
        }
      });
    {% endfor %}
  </script>
{% endif %}

{% if grouped_examples %}
<h2>Examples</h2>

    {% for subject, rows in grouped_examples.items() %}
        <h3>Example {{ loop.index }}</h3>
        <table>
            <tbody>
                {% for row in rows %}
                    <tr>
                        <th>{{ row.property }}</th>
                        <td>{% if row.property == 'Text' %}{{ row.object|safe }}{% else %}{{ row.object }}{% endif %}</td>
                    </tr>
                {% endfor %}
            </tbody>
        </table>
    {% endfor %}
{% endif %}

    {% if links %}
    <h2>Links</h2>
    <table border="1">
        {% for triple in links %}
            <tr>
                <td>{{ triple.property }}</td>
                <td>
                    {% if triple.href %}
                        <a href="{{ triple.href }}" target="_blank">{{ triple.object }}</a>
                    {% else %}
                        {{ triple.object }}
                    {% endif %}
                </td>
                <td>{{ triple.lang }}</td>
            </tr>
        {% endfor %}
    </table>
    {% endif %}


    <h2>Research</h2>
    <table border="1">
        {% for triple in research %}
            <tr>
                <th>{{ triple.property }}</th>
                <td>{{ triple.object }}</td>
            </tr>
        {% endfor %}
    </table>

    {% if research_data %}
    <h3>Evidence</h3>

    <table border="1">
        <tr>
            <th>Study</th>
            <th>Study type</th>
            <th>Study Summary</th>
        </tr>
        {% for triple in research_data %}
        <tr>
            <td>
                {% if triple.href %}
                    <a href="{{ url_for('app_studies.study_detail', uri=triple.href) }}" target="_blank"> {{ triple.title }} </a>
                {% else %}
                    {{ triple.title }}
                {% endif %}
            </td>
            <td>{{ triple.type }}</td>
            <td>{{ triple.summary }}</td>
        </tr>
        {% endfor %}
    </table>
    {% endif %}

    <h2>Metadata</h2>
    <table border="1">
        {% for triple in metadata %}
            <tr>
                <th>{{ triple.property }}</th>
                <td>{% if triple.homepage %}<a href="{{ triple.homepage }}" target="_blank">{{ triple.given }} {{ triple.family }}</a> {% endif %}
                    {% if not triple.homepage %} {{ triple.object }} {% endif %}
                </td>
            </tr>
        {% endfor %}
        {% for ref in references %}
            <tr>
                <th>References</th>
                <td class="reference">
                    {{ ref.authors }}
                    {% if not ref.authors %} {{ ref.editors }} {% if not ref.editors %} {{ ref.source }} {% endif %} {% endif %}
                    {% if ref.year %} ({{ ref.year }}). {% endif %}
                    <i>{{ ref.title }}</i>.
                    {% if ref.doi %}<a href="{{ ref.doi_href }}" target="_blank">{{ ref.doi }}</a> {% endif %}
                </td>
            </tr>
    {% endfor %}
    </table>


    <form id="downloadForm" method="POST">
    <button type="submit">Download the construction (RDF Turtle)</button>
    </form>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Get the current page's path
        const path = window.location.pathname;
        // Extract the "uri" part
        const uri = path.split('/').pop();
        // Set the form's action attribute using the correct URL
        document.getElementById('downloadForm').action =
            "{{ url_for('app_entries.download_subgraph', uri='') }}" + uri + "/submit";
    });
</script>

    <p>
    <a href="{{ url_for('app_entries.list_view') }}">Back to Constructions List</a>
    </p>

</body>
{% endblock %}
